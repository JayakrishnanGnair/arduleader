package com.geeksville.apiproxy

import java.net.Socket
import java.net.InetSocketAddress
import java.io.BufferedOutputStream
import com.geeksville.dapi._
import com.google.protobuf.ByteString
import java.io.BufferedInputStream
import java.net.URL
import com.geeksville.logback.Logging

class LoginFailedException(message: Option[ShowMsg]) extends Exception(message.flatMap(_.text).getOrElse("Login failed"))

class GCSHooksImpl(host: String = APIConstants.DEFAULT_SERVER, port: Int = APIConstants.DEFAULT_TCP_PORT) extends GCSHooks with Logging {
  private val socket = new Socket();
  socket.setTcpNoDelay(true); // Turn off nagle
  socket.connect(new InetSocketAddress(host, port))

  private val out = new BufferedOutputStream(socket.getOutputStream(), 8192)
  private val in = new BufferedInputStream(socket.getInputStream(), 8192)

  private val startTime = System.currentTimeMillis * 1000L

  private def send(e: Envelope) {
    e.writeDelimitedTo(out)
    out.flush()
  }

  /**
   * GCS must call this for ever mavlink packet received or sent from the
   * vehicle
   *
   * @param bytes
   *            the packet
   * @param fromInterface
   *            the interface # this data arrived on (or -1 if generated by
   *            the GCS itself)
   * @throws IOException
   */
  def filterMavlink(fromInterface: Int, bytes: Array[Byte]) {
    val deltat = (System.currentTimeMillis() * 1000) - startTime

    send(Envelope(mavlink = Some(MavlinkMsg(fromInterface, Vector(ByteString.copyFrom(bytes)), Some(deltat)))))
  }

  /// Ask server if the specified username is available for creation
  def isUsernameAvailable(userName: String) = {
    send(Envelope(login = Some(LoginMsg(LoginRequestCode.CHECK_USERNAME, userName))))
    val r = readLoginResponse()
    logger.debug(s"isUsernameAvailable response=$r")
    r.code == LoginResponseMsg.ResponseCode.OK
  }

  /// Create a new user account
  def createUser(userName: String, password: String, email: Option[String]) {
    send(Envelope(login = Some(LoginMsg(LoginRequestCode.CREATE, userName, password = Some(password), email = email, startTime = Some(startTime)))))
    val r = readLoginResponse()
    if (r.code != LoginResponseMsg.ResponseCode.OK)
      throw new LoginFailedException(r.message)
  }

  private def readEnvelope() = Envelope.parseDelimitedFrom(in).getOrElse(throw new Exception("No server response"))
  private def readLoginResponse() = readEnvelope().loginResponse.get

  /**
   * Connect to web service
   *
   * @param userName
   * @param password
   * @throws IOException
   * @throws UnknownHostException
   */
  def loginUser(userName: String, password: String) {
    send(Envelope(login = Some(LoginMsg(LoginRequestCode.LOGIN, userName, password = Some(password), startTime = Some(startTime)))))
    val r = readLoginResponse()
    if (r.code != LoginResponseMsg.ResponseCode.OK)
      throw new LoginFailedException(r.message)
  }

  override def startMission() {
    send(Envelope(startMission = Some(StartMissionMsg(keep = true))))
  }

  /**
   * Associate a server vehicleId string with a particular mavlink sysId. GCS
   * must call this for every vehicle that is connected.
   *
   * @param vehicleId
   *            a UUID for this vehicle, if the server has never seen this
   *            UUID before, a new vehicle record will be created. Use the
   *            special string "gcs" for data from the GCS (not really a
   *            vehicle)
   * @param fromInterface
   *            the interface # this vehicle is connected on
   * @param mavlinkSysId
   *            the mavlink sysid for this vehicle
   * @throws IOException
   */
  def setVehicleId(vehicleId: String, fromInterface: Int, mavlinkSysId: Int) {
    send(Envelope(setVehicle = Some(SetVehicleMsg(fromInterface, mavlinkSysId, vehicleId, false))))
  }

  /**
   * Send any queued messages immedately
   */
  def flush() {
    out.flush()
  }

  /**
   * Disconnects from web service
   */
  def close() {
    out.close()
    in.close()
    socket.close()
  }
}
