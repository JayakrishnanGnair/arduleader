package com.geeksville.apiproxy

import java.net.Socket
import java.util.UUID
import java.net.InetSocketAddress
import java.io.BufferedOutputStream
import com.geeksville.dapi._
import com.google.protobuf.ByteString
import java.io.BufferedInputStream
import java.net.URL
import com.geeksville.logback.Logging
import com.geeksville.util.ThreadTools
import com.geeksville.util.Using._
import java.net.SocketException

class LoginFailedException(message: Option[ShowMsg]) extends Exception(message.flatMap(_.text).getOrElse("Login failed"))

class CallbackLaterException(message: Option[ShowMsg], val delayMsec: Int) extends LoginFailedException(message)

class GCSHooksImpl(host: String = APIConstants.DEFAULT_SERVER, port: Int = APIConstants.DEFAULT_TCP_PORT, private val startTime: Long = System.currentTimeMillis * 1000L) extends GCSHooks with Logging {
  private val socket = new Socket();
  socket.setTcpNoDelay(true); // Turn off nagle
  socket.connect(new InetSocketAddress(host, port))

  private val out = new BufferedOutputStream(socket.getOutputStream(), 8192)
  private val in = new BufferedInputStream(socket.getInputStream(), 8192)

  // FIXME - change to use the fancy akka TCP API or zeromq so we don't need to burn a thread for each client)
  private val listenerThread = ThreadTools.createDaemon("TCPGCS")(readerFunct)

  private var callbacks: Option[GCSCallback] = None

  private def readerFunct() {
    try {
      val default = Envelope.defaultInstance
      val cb = callbacks.get

      // Any Envelopes that come over TCP, extract the message and handle just like any other actor msg
      using(in) { is =>
        // Real until we see an invalid envelope - FIXME, don't hang up in this case?
        Stream.continually(default.mergeDelimitedFromStream(is)).takeWhile { o =>
          // log.warning(s"Considering $o")
          o.isDefined
        }.foreach { mopt =>
          mopt.foreach { env =>
            //logger.debug(s"Got packet $env")

            // FIXME - use the enum to more quickly find the payload we care about
            env.mavlink.foreach { m =>
              //logger.debug(s"Dispatching $m")
              m.packet.foreach { p =>
                cb.sendMavlink(p.toByteArray)
              }
            }
          }
        }
      }
    } catch {
      case ex: SocketException =>
        logger.error(s"Exiting client reader due to: $ex")
    } finally {
      logger.debug("Client reader shutting down")

      // If our reader exits, shut everything down
      close()
    }
  }

  def send(e: Envelope) = synchronized {
    e.writeDelimitedTo(out)
    out.flush()
  }

  def setCallback(cb: GCSCallback) {
    callbacks = Some(cb)
    listenerThread.start()
  }

  /**
   * GCS must call this for ever mavlink packet received or sent from the
   * vehicle
   *
   * @param bytes
   *            the packet
   * @param fromInterface
   *            the interface # this data arrived on (or -1 if generated by
   *            the GCS itself)
   * @throws IOException
   */
  def filterMavlink(fromInterface: Int, bytes: Array[Byte]) {
    val deltat = (System.currentTimeMillis() * 1000) - startTime

    send(Envelope(mavlink = Some(MavlinkMsg(fromInterface, Vector(ByteString.copyFrom(bytes)), Some(deltat)))))
  }

  /// Ask server if the specified username is available for creation
  def isUsernameAvailable(userName: String) = {
    send(Envelope(login = Some(LoginMsg(LoginRequestCode.CHECK_USERNAME, userName))))
    val r = readLoginResponse()
    logger.debug(s"isUsernameAvailable response=$r")
    r.code == LoginResponseMsg.ResponseCode.OK
  }

  /// Create a new user account
  def createUser(userName: String, password: String, email: Option[String]) {
    send(Envelope(login = Some(LoginMsg(LoginRequestCode.CREATE, userName, password = Some(password), email = email, startTime = Some(startTime)))))
    checkLoginOkay()
  }

  private def readEnvelope() = Envelope.parseDelimitedFrom(in).getOrElse(throw new Exception("No server response"))
  private def readLoginResponse() = {
    flush() // Make sure any previous commands has been sent
    val r = readEnvelope().loginResponse.get

    // No matter what, if the server is telling us to hang up, we must bail immediately
    if (r.code == LoginResponseMsg.ResponseCode.CALL_LATER)
      throw new CallbackLaterException(r.message, r.callbackDelay.getOrElse(10 * 60 * 1000))

    r
  }

  private def checkLoginOkay() {
    val r = readLoginResponse()
    if (r.code != LoginResponseMsg.ResponseCode.OK)
      throw new LoginFailedException(r.message)
  }

  /**
   * Connect to web service
   *
   * @param userName
   * @param password
   * @throws IOException
   * @throws UnknownHostException
   */
  def loginUser(userName: String, password: String) {
    send(Envelope(login = Some(LoginMsg(LoginRequestCode.LOGIN, userName, password = Some(password), startTime = Some(startTime)))))
    checkLoginOkay()
  }

  override def startMission(keep: Boolean, uuid: UUID) {
    send(Envelope(startMission = Some(StartMissionMsg(keep = keep, uuid = Some(uuid.toString)))))
  }

  override def stopMission(keep: Boolean) {
    send(Envelope(stopMission = Some(StopMissionMsg(keep = keep))))
  }

  def setVehicleId(vehicleId: String, fromInterface: Int, mavlinkSysId: Int, allowControl: Boolean) {
    send(Envelope(setVehicle = Some(SetVehicleMsg(fromInterface, mavlinkSysId, vehicleId, allowControl))))
  }

  /**
   * Send any queued messages immedately
   */
  def flush() {
    out.flush()
  }

  /**
   * Disconnects from web service
   */
  def close() {
    out.close()
    in.close()
    socket.close()
  }
}
